################################################################################
#' tagCountTSS
#' @description Returns a matrix [a, h] where a = the number of unique TSSs
#' and h = the # of tags observed at that position
#'
#' @import BiocGenerics
#' @import GenomicRanges
#' @importFrom utils write.table
#'
#' @keywords internal


tagCountTSS <- function(y, outfname="TSS.txt", writeDF=FALSE) {
    x <- S4Vectors::split(y,seqnames(y))
    n.seq <- length(x)

    my.matrix <- NULL
    for (i in 1:n.seq) {
#VB Note: Print a progress note on every 20th sequence; 20 should be a parameter
        if (i%%20 == 0) {
            message("... tagCountTSS running with sequence ", i,
                " of ", n.seq, " for TSS set ", outfname, "\n")
        }
        this.seq <- as.character(x[[i]]@seqnames@values[1])

        #starting with the plus strand:
        tss.vec <- start(x[[i]][strand(x[[i]]) == "+"])
        if (length(tss.vec) > 3) {	#stop if there are nearly no tags
            my.TSSs <- unique(tss.vec)
            my.matrix.p <- matrix(NA, nrow=(length(my.TSSs)), ncol=4)

            tss.vec[1] -> this.TSS
            1 -> n.TSSs
            0 -> k
            for (j in 2:length(tss.vec)) {
                if (tss.vec[j] == this.TSS) {
                    n.TSSs + 1 -> n.TSSs
                }
                else {
                    k + 1 -> k
                    c(this.seq, this.TSS, "+", n.TSSs) -> my.matrix.p[k,]
                    tss.vec[j] -> this.TSS
                    1 -> n.TSSs
                }
            }
            k + 1 -> k
            c(this.seq, this.TSS, "+", n.TSSs) -> my.matrix.p[k,]
# ... adding the plus strand matrix of this.seq to the overall matrix:
            my.matrix <- rbind(my.matrix,my.matrix.p)
        }

        #now for the minus strand:
        tss.vec <- start(x[[i]][strand(x[[i]]) == "-"])
        if (length(tss.vec) > 3) {
# ... no point continuing when there are almost no TSS tags
            my.TSSs <- unique(tss.vec)
            my.matrix.m <- matrix(NA, nrow=(length(my.TSSs)), ncol=4)

            tss.vec[1] -> this.TSS
            1 -> n.TSSs
            0 -> k
            for (j in 2:length(tss.vec)) {
                if (tss.vec[j] == this.TSS) {
                    n.TSSs + 1 -> n.TSSs
                }
                else {
                    k + 1 -> k
                    c(this.seq, this.TSS, "-", n.TSSs) -> my.matrix.m[k,]
                    tss.vec[j] -> this.TSS
                    1 -> n.TSSs
                }
            }
            k + 1 -> k
            c(this.seq, this.TSS, "-", n.TSSs) -> my.matrix.m[k,]
# ... adding the minus strand matrix of this.seq to the overall matrix:
            my.matrix <- rbind(my.matrix,my.matrix.m)
        }
    }
    colnames(my.matrix) <- c("seq","TSS","strand","nTSSs")
    my.df <- as.data.frame(my.matrix)
    my.df$seq <- as.character(my.df$seq)
    my.df$TSS <- as.numeric(as.character(my.df$TSS))
    my.df$strand <- as.character(my.df$strand)
    my.df$nTSSs <- as.numeric(as.character(my.df$nTSSs))

    if (writeDF==TRUE) {
        write.table(my.df, outfname, quote=FALSE, col.names=TRUE,
                    row.names=FALSE, sep="\t")
        message("\nThe TSS dataset has been written to file ", outfname,
                "\nin your working directory.")
    }

    return(my.df)
}


################################################################################
#' @title tsrCluster
#' @description Partitions, then clusters tss data by sequence.
#'
#' @keywords internal
#'
#' @return A list of TSRs from the data frame generated by
#' \code{\link{tagCountTSS}}


tsrCluster <- function(x, minNbrTSSs=3, minDist=20) {
    tss.df <- x
    uni.seq <- unique(tss.df[,1])
    n.seq <- length(uni.seq)
    overall.list <- vector(mode="list", length=n.seq)

    for (l in 1:n.seq) { #by sequence
        subset(tss.df, seq==uni.seq[l]) -> this.tss
        subset(this.tss, this.tss$nTSSs>=minNbrTSSs) -> sTSS

        #... clustering TSS on the plus strand:

        subset(sTSS, strand=="+") -> sTSS.p
        as.matrix(sTSS.p) -> sTSS.p
        nrow(sTSS.p) -> my.len
        if (my.len == 0) { # ... create an empty list tss.list.p
            vector(mode="list") -> tss.list.p
        }
        else if (my.len == 1) {
            vector(mode="list") -> tss.list.p
            as.numeric(sTSS.p[1,2]) -> my.tss
            as.numeric(sTSS.p[1,4]) -> my.count
            rbind(my.tss, my.count) -> combined.tss
            c("coordinate","count") -> rownames(combined.tss)
            (1:ncol(combined.tss)) -> colnames(combined.tss)
            combined.tss -> tss.list.p[[1]]
        }
        else {
            vector(mode="list") -> tss.list.p
            as.numeric(sTSS.p[1,2]) -> my.tss
            as.numeric(sTSS.p[1,4]) -> my.count
            0 -> j
            for (i in 1:(my.len-1)) {
                as.numeric(sTSS.p[i,2]) -> tss.1
                as.numeric(sTSS.p[i,4]) -> tss.1.count
                as.numeric(sTSS.p[i+1,2]) -> tss.2
                as.numeric(sTSS.p[i+1,4]) -> tss.2.count
                abs(tss.2-tss.1) -> tss.dist
                if (tss.dist < minDist) {
                    c(my.tss,tss.2) -> my.tss
                    c(my.count, tss.2.count) -> my.count
                    if (i == my.len-1) {	# wrapping up the last TSR
                        j + 1 -> j
                        rbind(my.tss, my.count) -> combined.tss
                        c("coordinate","count") -> rownames(combined.tss)
                        (1:ncol(combined.tss)) -> colnames(combined.tss)
                        combined.tss -> tss.list.p[[j]]
                    }
                    next
                }
                else {
                    j + 1 -> j
                    rbind(my.tss, my.count) -> combined.tss
                    c("coordinate","count") -> rownames(combined.tss)
                    (1:ncol(combined.tss)) -> colnames(combined.tss)
                    combined.tss -> tss.list.p[[j]]
                    tss.2 -> my.tss
                    tss.2.count -> my.count
                }
            }
        }
        if (my.len > 0) {
            names.len <- length(tss.list.p)
            names.vec <- vector(mode="character",length=names.len)
            for (k in 1:names.len) {
                paste("tsr", k, sep="") -> names.vec[k]
            }
            names.vec -> names(tss.list.p)
        }

        #... clustering TSS on the minus strand:

        subset(sTSS, strand=="-") -> sTSS.m
        as.matrix(sTSS.m) -> sTSS.m
        nrow(sTSS.m) -> my.len
        if (my.len == 0) { # ... create an empty list tss.list.m
            vector(mode="list") -> tss.list.m
        }
        else if (my.len == 1) {
            vector(mode="list") -> tss.list.m
            as.numeric(sTSS.m[1,2]) -> my.tss
            as.numeric(sTSS.m[1,4]) -> my.count
            rbind(my.tss, my.count) -> combined.tss
            c("coordinate","count") -> rownames(combined.tss)
            (1:ncol(combined.tss)) -> colnames(combined.tss)
            combined.tss -> tss.list.m[[1]]
        }
        else {
            vector(mode="list") -> tss.list.m
            as.numeric(sTSS.m[1,2]) -> my.tss
            as.numeric(sTSS.m[1,4]) -> my.count
            0 -> j
            for (i in 1:(my.len-1)) {
                as.numeric(sTSS.m[i,2]) -> tss.1
                as.numeric(sTSS.m[i,4]) -> tss.1.count
                as.numeric(sTSS.m[i+1,2]) -> tss.2
                as.numeric(sTSS.m[i+1,4]) -> tss.2.count
                abs(tss.2-tss.1) -> tss.dist
                if (tss.dist < minDist) {
                    c(my.tss,tss.2) -> my.tss
                    c(my.count, tss.2.count) -> my.count
                    if (i == my.len-1) {	# wrapping up the last TSR
                        j + 1 -> j
                        rbind(my.tss, my.count) -> combined.tss
                        c("coordinate","count") -> rownames(combined.tss)
                        (1:ncol(combined.tss)) -> colnames(combined.tss)
                        combined.tss -> tss.list.m[[j]]
                    }
                    next
                }
                else {
                    j + 1 -> j
                    rbind(my.tss, my.count) -> combined.tss
                    c("coordinate","count") -> rownames(combined.tss)
                    (1:ncol(combined.tss)) -> colnames(combined.tss)
                    combined.tss -> tss.list.m[[j]]
                    tss.2 -> my.tss
                    tss.2.count -> my.count
                }
            }
        }
        if (my.len > 0) {
            length(tss.list.m) -> names.len
            vector(mode="character",length=names.len) -> names.vec
            for (k in 1:names.len) {
                paste("tsr", k, sep="") -> names.vec[k]
            }
            names.vec -> names(tss.list.m)
        }
        list(plus=tss.list.p, minus=tss.list.m) -> tss.list
        tss.list -> overall.list[[l]]

    }	#end of by sequence for-loop

    names(overall.list) <- uni.seq
    return(overall.list)
}
